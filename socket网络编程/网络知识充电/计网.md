# 计算机网络

## OSI七层模型

&emsp;&emsp;通过下图，我们能够知道OSI七层模型分别为：

1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流。即底层数据传输。
2. 数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。
3. 网络层：定义了IP编制，定义路由功能，如不同设备的数据转发。
4. 传输层：定义了一些传输数据的协议和端口号。
5. 会话层：通过传输层（端口号：传输端口和接收端口）建立数据传输的通路。控制应用程序之间会话的能力。
6. 表示层：数据格式标识，基本压缩加密功能。
7. 应用层：各种应用软件。


![image](https://user-images.githubusercontent.com/81791654/166210520-656d1b1a-98dc-42ca-8b04-17c19da7bfc7.png)

## 什么是协议

### 典型协议

* 传输层 常见协议有TCP/UDP协议。

&emsp;&emsp;TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

&emsp;&emsp;UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

>一般，域名解析用UDP协议，区域传送用TCP协议。
>因为，UDP的特点是快，它只需要一个请求，一个应答就可以。所以它用来域名解析。而TCP协议的特点是可靠性高，而且其传输的内容大。所以常用来区域传输。


* 应用层 常见的协议有HTTP协议，FTP协议。

&emsp;&emsp;HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。

&emsp;&emsp;FTP文件传输协议（File Transfer Protocol）

* 网络层 常见协议有IP协议、ICMP协议、IGMP协议。

&emsp;&emsp;IP协议是因特网互联协议（Internet Protocol）

&emsp;&emsp;ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

&emsp;&emsp;IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。

* 网络接口层 常见协议有ARP协议、RARP协议。

&emsp;&emsp;ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。

&emsp;&emsp;RARP是反向地址转换协议，通过MAC地址确定IP地址。




## 网络应用程序设计模式

### C/S模式

&emsp;&emsp;传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。

### B/S模式

&emsp;&emsp;浏览器()/服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。

### 优缺点

&emsp;&emsp;对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。

&emsp;&emsp;C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。

&emsp;&emsp;B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。

&emsp;&emsp;B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。

### 通信过程

&emsp;&emsp;两台计算机通过TCP/IP协议通讯的过程如下所示：


&emsp;&emsp;上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：


&emsp;&emsp;链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。

&emsp;&emsp;网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Internet上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。

&emsp;&emsp;网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。

&emsp;&emsp;TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。

&emsp;&emsp;UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。

&emsp;&emsp;目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：


&emsp;&emsp;以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。

&emsp;&emsp;虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。

## TCP 协议

### TCP通信时序

&emsp;&emsp;下图是一次TCP通讯的时序图。TCP连接建立断开。包含三次握手和四次握手。

![image](https://user-images.githubusercontent.com/81791654/166210698-7c57d807-ca63-4189-b488-e293796dbd12.png)

**三报文握手：**

&emsp;&emsp;三次握手其实就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

>建立连接（三次握手）的过程：

>刚开始客户端处于Closed的状态，服务端处于Listen状态，进行三次握手：

>&emsp;&emsp;第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND状态。（首部的同步位SYN=1,初始化序列号seq=x,SYN=1的报文段不饿能携带数据，但要消耗掉一个序号。）

>&emsp;&emsp;第二次握手：服务器接收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN+1作为自己的ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_RCVD状态。（在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

>&emsp;&emsp;第三次握手：客户端收到SYN报文后，会发送一个ACK报文，当然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED状态。服务器收到ACK报文之后，也处于ESTABLISHED状态，此时，双方已建立起了连接。（确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为x，第二个报文段所以+1），ACK报文段可以携带数据，不携带数据则不消耗序号。）

**在socket编程中，客户端执行connect()时，将触发三次握手。**

思考题1：为什么需要三次握手，两次不行吗？

&emsp;&emsp;弄清楚这个问题，我们需要先弄明白三次握手的目的是什么，能不能用两次握手来达到这个目的？

&emsp;&emsp;第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

&emsp;&emsp;第二次握手：服务端发送包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的发送接受能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

&emsp;&emsp;第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端接收和发送能力正常，服务器自己接收发送能力也正常。

因此，需要三次握手才能确认双方的接收和发送能力是否正常。

&emsp;&emsp;试想如果是两次握手，则会出现下面这种情况。

&emsp;&emsp;如果客户端发送连接请求，但因连接请求丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发送了两个连接请求报文段。其中一个丢失了，第二个到达了服务端，但是第一个丢失的报文段这只是在某些网络结点长时间滞留，延误到连接释放后的某个时间段才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发送确认报文段，同意建立连接，不采样三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费了资源。

思考题2：三次握手过程中可以携带数据吗？

其实第三次握手的时候是可以携带数据的。但是第一次和第二次不能携带。

为什么？加入第一次握手可以携带数据的话，如果有人恶意攻击服务器，那么他可以在第一次握手中的SYN报文中放入大量的数据，因为攻击者根本不理服务器的接收、发送能力是否正常，然后重复发SYN报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，第一次握手不放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了。并且也知道服务器的接收、发送能力是正常的了，所以能携带数据也没问题。

**四报文挥手：**

&emsp;&emsp;建立一个连接需要三次握手，终止一个连接需要四次挥手。这是TCP的半关闭造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

>关闭连接（四次握手）的过程：

>刚开始双方都处于ESTABLISHED状态，假如是客户端先发起关闭请求。四次挥手过程如下：

>第一次挥手：客户端发送一个FIN报文，报文会指定一个序列号。此时客户端处于FIN_WAIT1状态。即发出连接释放报文段（FIN=1，序号seq=u),并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

>第二次挥手


### TCP状态转换

![image](https://user-images.githubusercontent.com/81791654/166246730-a2c9d530-9c7c-4490-99ae-00f25a843abd.png)

CLOSED：表示初始状态。

LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。

SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。

SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。

ESTABLISHED：表示连接已经建立。

FIN_WAIT_1:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：

FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。

FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。

FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。

TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。

LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。




